/* grader.java */
/* By Aneesh Prasad */

                                     GRADER

Name of student running submit: Mike Zhong
Login of student running submit: cs61b-ov

Second team member's name: Aneesh Prasad
Second team member's login: cs61b-sx

Third team member's name (if any): David Smith
Third team member's login: cs61b-apk 

IMPORTANT:  Once you've submitted Project 2 once, the same team member should
submit always.  If a different teammate must submit, inform cs61b@cory.eecs of
all the details.  Include a complete list of team members, and let us know
which submission you want graded.

If you've submitted your project once, or even written a substantial amount of
code together, you may not change partners without the permission of the
instructor.
===============================================================================
Does your program compile without errors?
Yes

Have you tested your program on the 61B lab machines?
Yes

Did you successfully implement game tree search?  Did you successfully
implement alpha-beta pruning?  Are there any limitations on it?  What is the
default number of search levels set by the one-parameter MachinePlayer
constructor (or is it a variable-depth search)?
Yes, default search depth is 2.

Describe your board evaluation function in some detail.
Our evaluation function takes into account the longest Networks on the board
and how many of them there could be using longestNetworkN. It weights them 
and uses that to return a score

Does your MachinePlayer use any special method of choosing the first few moves?
No

Is there anything else the graders should know to help them read your project?
We used a Chip class that contains information on not just the adjacent squares,
but rather their nearest neighbor. So chips can contain up to 8 neighbors,
of any color and at any distance in one of the 8 directions. This makes
implementing bigger methods, such as hasValidNetwork, a lot easier.


Describe the classes, modules, and interfaces you designed before and while you
implemented the project.  Your description should include:
  -  A list of the classes your program uses.
  -  A list of each of the "modules" used in or by MachinePlayer, similar to
     the list in the "Teamwork" section of the README (but hopefully more
     detailed).  (If you're using a list class, that should probably count as
     a separate module.)
  -  For each module, list the class(es) the module is implemented in.
  -  For each module, say which of your team members implemented it.
  -  For each module, describe its interface--specifically, the prototype and
     behavior of each method that is available for external callers (outside
     the module) to call.  Don't include methods that are only meant to be
     called from within the module.

     For each method, provide (1) a method prototype and (2) a complete,
     unambiguous description of the behavior of the method/module.  This
     description should also appear before the method in your code's comments.

You will probably need to change some of your design decisions as you go; be
sure to modify this file to reflect these changes before you submit your
project.  Your design of classes and interfaces will be worth 10% of your
grade.

=========
OVERVIEW
=========

/**
 *  GameBoard
 *    Chip[][] board;
 *    DList[] placedChips;
 *    int[] directions;
 *    int whoseTurn;
 *
 *    GameBoard(); // constructor
 *    makeMove(Move m, int color); // @return void
 *    undoMove(Move m); // @return void
 *    isValidSquare(int x, int y); // @return boolean
 *    hasChip(int x, int y); // @return boolean
 *    getChip(int x, int y); // @return Chip
 *    setChip(int x, int y, int color); // @return void
 *    removeChip(int x, int y); // @return void
 *    moveChip(int x1, int y1,
 *             int x2, int y2); // @return void
 *    makeConnections(Chip c); // @return void
 *    removeConnections(Chip c); // @return void
 *
 *    hasValidNetwork(int color); // @return boolean
 *    longestNetworkN(int color); // @return int[]
 *    numberAdjacentChips(int x, int y, int color,
 *                        int avoidX, int avoidY); // @return int
 *    isRightTurn(int color); // @return boolean
 *
 *    isValidMove(Move m, int color); // @return boolean
 *    listValidMoves(int color); // @return DList
 *    evaluation(); // @return float
 *
 *
 *  MachinePlayer
 *    int color;
 *    int searchDepth;
 *    GameBoard board;
 *
 *    MachinePlayer(int color); // constructor
 *    MachinePlayer(int color, int searchDepth); // constructor
 *    chooseMove(); // @return Move
 *    bestMove(int color, int alpha,
 *             int beta, int depth); // @return Best
 *    opponentMove(Move m); // @return boolean
 *
 *
 *  Direction
 *    int SW; // 1
 *    int S; // 2
 *    int SE; // 3
 *    int W; // 4
 *    int E; // 6
 *    int NW; // 7
 *    int N; // 8
 *    int NE; // 9
 *    int[] directions; {SW, S, SE, W, E, NW, N, NE};
 *
 *    incrementX(int dir); // @return int
 *    incrementY(int dir); // @return int
 *    indexX(int dir); // @return int
 *    indexY(int dir); // @return int
 *    opposite(int dir); // @return int
 *
 *
 *  Chip
 *    int x, y;
 *    int color;
 *    GameBoard board;
 *    Chip[][] connections;
 *
 *    Chip(GameBoard board,
 *         int x, int y, int color); // constructor
 *    getColor(); // @return int
 *    setPosition(int x, int y); // @return void
 *    getPosition(); // @return int[]
 *    hasConnection(int dir); // @return boolean
 *    setConnection(int dir, Chip c); // @return void
 *    getConnection(int dir); // @return Chip
 *    removeConnection(int dir); // @return void
 *    toString(); // @return String
 *
 *
 *  Best
 *    Move move;
 *    float score;
 **/

=======
MODULES
=======

/**
 *  Responsibility: David
 *  Implemented in: GameBoard
 *  hasValidNetwork() determines whether "this" GameBoard has a valid network
 *  for player "side".  (Does not check whether the opponent has a network.)
 *  A full description of what constitutes a valid network appears in the
 *  project "readme" file.
 *
 *  Unusual conditions:
 *    If side is neither MachinePlayer.COMPUTER nor MachinePlayer.OPPONENT,
 *          returns false.
 *    If GameBoard squares contain illegal values, the behavior of this
 *          method is undefined (i.e., don't expect any reasonable behavior).
 *
 *  @param color is 0 (black) or 1 (white)
 *  @return true if player "side" has a winning network in "this" GameBoard;
 *          false otherwise.
 **/
protected boolean hasValidNetwork(int color);


/**
 *  Responsibility: David
 *  Implemented in: GameBoard
 *  isValidMove() determines whether Move "m" is a valid move on "this" 
 *  GameBoard.
 *  
 *  A full description of what constitutes a valid move appears in the project
 *  "readme" file.
 *
 *  @param m is Move
 *  @param color is 0 (black) or 1 (white)
 *  @return true if Move "m" is valid on "this" GameBoard. false otherwise.
 **/
protected boolean isValidMove(Move m, int color);


/**
 *  Responsibility: Mike and Aneesh
 *  Implemented in: GameBoard
 *  evaluation() is a static evaluation heuristic that assigns a score to "this"
 *  GameBoard estimating how well your MachinePlayer is doing. It is impossible
 *  to search the entire depth of the game, so this heuristic is necessary to
 *  estimate the odds of winning if the MachinePlayer makes a particular move.
 *  This function assigns a maximum positive score of 1 to a win by the
 *  MachinePlayer and a minimum negative score to a win by the opponent. An
 *  intermediate score will be assigned to a board where neither player has
 *  completed a network. 
 *
 *  A slightly higher score will be assigned to a win in fewer moves than
 *  otherwise.
 *
 *  @return float from -1 to 1 based on how good a board is for the given color,
 *          aka the MachinePlayer
 **/
protected float evaluation();


/**
 *  Responsibility: David
 *  listValidMoves() retrieves an array of all the valid moves
 *  as determined by looping through the "this" GameBoard's
 *  isValidMove() method across all unfilled spaces of the
 *  GameBoard.
 *
 *  @param color is 0 (black) or 1 (white)
 *  @return moves is an array of Moves that are valid
 **/
protected DList listValidMoves(int color);


/**
 *  Responsibility: Mike and Aneesh
 *  Implemented in: MachinePlayer
 *  bestMove() uses alpha-beta pruning search techniques in
 *  order to speed up the search through a game tree.
 *  
 *  @param color is 0 (black) or 1 (white)
 *  @param alpha is the guaranteed score for white
 *  @param beta is the guaranteed score for black
 *  @param depth is the search depth
 *  @return Best is contains both the move and the score
 **/
protected Best bestMove(int color, int alpha,
		   	int beta, int depth);

/**
 *  Responsibility: Aneesh
 *  Implemented in: Chip
 *  getConnection() gets the nearest Chip in the given Direction
 *  "dir".
 *  @param dir is a number representing the desired direction
 *  @return the nearest Chip in the Direction "dir"
 **/
public Chip getConnection(int dir)
    