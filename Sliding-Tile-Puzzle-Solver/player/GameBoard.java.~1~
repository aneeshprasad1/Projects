/* GameBoard.java */

package player;



public class GameBoard { // default ... or private?    
   
    Chip[][] board;
    Chip[][] placedChips; // whiteChips and blackChips
    int[] directions = Direction.directions; // {SW, S, SE, W, E, NW, N, NE}
    int whoseTurn;

    public GameBoard() {
        board = new Chip[8][8]; // 8 by 8 board
        placedChips = new Chip[2][10];
        whoseTurn = 1;
    }

    public void makeMove(Move m, int color) {
        whoseTurn = 1 - whoseTurn;
        if (m.moveKind == 0) {
	    System.out.println("Good game!"); // quit?
        } else if (m.moveKind == 1) {
            setChip(m.x1, m.y1, color);
        } else { // m.moveKind == 2
            moveChip(m.x1, m.y1, m.x2, m.y2);
        }
    }

    public void undoMove(Move m) { // undos move! 
        // for add move, use removeChip
        // for step moves, use moveChip with reversed x1, y1
        whoseTurn = 1 - whoseTurn;
        if (m.moveKind == 1) {
            removeChip(m.x1, m.y1);
        } else {
            moveChip(m.x2, m.y2, m.x1, m.y1);
        }
    }


    private boolean isValidSquare(int x, int y) {
        return ((x >= 0) || (x < 8) || (y >= 0) || (y < 8) ||
                ( ((x == 0) || (x == 7)) && ((y == 0) || (y == 7)) ));



	//      return ((x >= 0) && (x < 8) && (y >= 0) && (y < 8) &&
	//                ( ((x == 0) || (x == 7)) && ((y == 0) || (y == 7)) ));
	//	return ((x <= 0) || (x > 8) || (y <= 0) || (y > 8) ||
	//		( ((x == 0) || (x == 7)) && ((y == 0) || (y == 7)) ) );
    }

    private boolean hasChip(int x, int y) {
        if (!isValidSquare(x, y)) {
            return false;
        }
    	return (board[x][y] != null);
    }

    private Chip getChip(int x, int y) {
        if (!hasChip(x, y)) {
            return null;
        }
        return board[x][y];
    }

    private void setChip(int x, int y, int color) {
        Chip c = new Chip(this, x, y, color);
        int numberChips = placedChips[color].length
	    placedChips[color][numberChips] = c;
        board[x][y] = c;
        makeConnections(c);
    }

    private void removeChip(int x, int y) { // this is solely for undoing moves
        Chip c = getChip(x, y);
        removeConnections(c);
        board[x][y] = null;
        for (int i = 0; i < 10; i++) {
            if (placedChips[c.getColor()][i] == 0) {
                placedChips[c.getColor()][i] = null;
            }
        }
    }

    private void moveChip(int x1, int y1, int x2, int y2) {
        Chip c = getChip(x1, y1);
        removeConnections(c);
        board[x1][y1] = null;
        c.setPosition(x2, y2);
        board[x2][y2] = c;
        makeConnections(c);
    }

    /* 
     * makeConnections(Chip c)
     * crawls in various directions ... makes connections of chips if so!
     */
    private void makeConnections(Chip c) {
        Chip tempC;
        int dir;
        for (int i = 0; i < 8; i++) {
            dir = directions[i];
            tempX = this.x + Direction.incrementX(dir); // do while?
            tempY = this.y + Direction.incrementY(dir);
            while (isValidSquare(tempX, tempY)) {
                if (hasChip(tempX, tempY)) {
                    tempC = getChip(tempX, tempY);
                    c.setConnection(dir, tempC);
                    tempC.setConnection(Direction.opposite(dir), c); // 
                    break;
                }
                tempX += Direction.incrementX(dir);
                tempY += Direction.incrementY(dir);
            }
        }
    }

    private void removeConnections(Chip c) {
        Chip tempC;
        int dir;
	for (int i = 0; i < 8; i++) {
            dir = directions[i];
            if (c.hasConnection(dir)) {
		tempC = c.getConnection(dir);
                tempC.setConnection(c.getConnection(Direction.opposite(dir)), 
				    Direction.opposite(dir));
            }
        }
        for (int i = 0; i < 8; i++) {
            c.removeConnection(directions[i]);
        }
    }


    public boolean hasValidNetwork(int color) {
        boolean outcome = false;
        Chip[] checked = new Chip[10];
        if (color == 0) {
            for (int x = 1; x < 7; x++) {
                if (hasChip[x][0]) {
                    if (validNetworkHelper(getChip[x][0], checked, directions[3])) {
                        return true;
                    }
                }
            }
        } else {
            for (int y = 1; y < 7; y++) {
                if (hasChip[0][y]) {
                    if (validNetworkHelper(getChip[0][y], checked, directions[1])) {
                        return true;
                    }
                }
            }
        }
    }

    private boolean validNetworkHelper(Chip current, Chip[] checked, int dir) {
        Chip connected;
        if (current == null) {return false; } // this should no longer be necessary to check.
        for (int i = 0; i < 10; i++) {
            if (current == checked[i]) {
                return false;
            }
        }
        checked[checked.length] = current;

        // if chip is in the endzone ... it's over!
	if (current.getPosition()[current.getColor()] == 7) {
            if (checked.length >= 6) {return true; }
            return false;
        }

        if ((checked.length > 1) && (current.getPosition()[current.getColor()] == 0)) {
            return false;
        }

        for (int i = 0; i < 8; i++) {
            if ((i = dir) || (i = Directions.opposite(dir))) {continue; } // skip same direction
            if (!c.hasConnection(dir)) {continue; }
            connected = c.getConnection(dir);
            if (connected.getColor() != c.getColor()) {continue; }
            if (networkHelper(connected, Chip[] checked, dir)) {return true; }
        }
        return false;
    }


    // this should be implemented last (only part of evaluation)
    // returnvalue[0] = length of longest network
    // returnvalue[1] = number of times it occurs
    private int[] longestNetworkN(int color) {
        Chip[] checked = new Chip[10];
        int n = 0;
        int maxLength = 0;
        int[] current;
        if (color == 0) {
            for (int x = 1; x < 7; x++) {
                if (hasChip[x][0]) {
                    current = longestNetworkHelper(getChip[x][0], checked, directions[3], 0)
			if (current[0] > maxLength) {
			    maxLength = current[0];
			    n = current[1];
			} else if (current[0] == maxLength) {
			    n += current[1]
				}
                }
            }
        } else {
            for (int y = 1; y < 7; y++) {
                if (hasChip[0][y]) {
                    current = longestNetworkHelper(getChip[0][y], checked, directions[1], 1)
			if (current[0] > maxLength) {
			    maxLength = current[0];
			    n = current[1];
			} else if (current[0] == maxLength) {
			    n += current[1]
				}
                }
            }
        }
        current[0] = maxLength;
        current[1] = n;
        return current;
    }

    // this should be implement last (only part of evaulation)
    private int[] longestNetworkHelper(Chip c, Chip[] checked, int dir, int n) {
        Chip connected;
        int[] current = {checked.length, n}
        int maxLength = checked.length;
        int maxN = n;

        if (c == null) {return false; } // this should no longer be necessary to check.
        for (int i = 0; i < 10; i++) {
            if (c == checked[i]) {
                return current;
            }
        }

        checked[checked.length] = c;

        if ((checked.length > 1) && (c.getPosition()[c.getColor()] == 0)) { // endzone
            current[1] = n;
            return current;
        }

        for (int i = 0; i < 8; i++) {
            if ((i = dir) || (i = Directions.opposite(dir))) {continue; } // skip same direction
            if (!c.hasConnection(dir)) {continue; }
            connected = c.getConnection(dir);
            if (connected.getColor() != c.getColor()) {continue; }
            current = (networkHelper(connected, Chip[] checked, dir, n));
            if (current[0] > maxLength) {
                maxLength = current[0];
                n = current[1];
            } else if (current[0] == maxLength) {
                n += current[1]];
	}
    }
    current[0] = maxLength;
    current[1] = n
        return current;
}

private int numberAdjacentChips(int x, int y, int color, int avoidX, int avoidY) {
    int dir;
    int count = 0;
    for (int i = 0; i < 8; i++) {
	dir = directions[i];
	if ((x + Direction.incrementX(dir) == avoidX) && (y + Direction.incrementX(dir) == avoidY)) {continue; }
	if ((hasChip(x + Direction.incrementX(dir), y + Direction.incrementX(dir))) &&
	    (getChip(x + Direction.incrementX(dir), y + Direction.incrementY(dir)).getColor() == color)) {
	    count += 1
		}
    }
    return count;
}

// this checks if it's the right turn!
public boolean isRightTurn(int color) {
    return (color == whoseTurn);
}

// isValidMove does NOT check for right turns. (we need it use it to list possible moves for evaluation)
public boolean isValidMove(Move m, int color) {
    // quiting is always a valid Move!! B-) .....?
    if (m.movekind == 0) {return true; }

    else if (m.movekind == 1) {
	if (color == 0) {
	    if ((m.y1 == 0) || (m.y1 == 7)) {return false; }
	} else {
	    if ((m.x1 == 0) || (m.x1 == 7)) {return false; }
	}
	if (placedChips[color].length == 10) {return false; }
	if !isValidSquare(m.x1, m.y1) {return false; }
	if hasChip(m.x1, m.y1) {return false; }

	// checks for 3+ adjacent 'islands', if there are 2 next to the square to which chip is placed
	if (numberAdjacentChips(m.x1, m.y1, color, m.x1, m.y1) > 1) {return false; }


	// checks for 3+ adjacent 'islands', if an adjacent chip already has another adjacent chip
	for (int i = 0; i < 8; i++) {
	    dir = directions[i];
	    if (hasChip(m.x1 + Direction.incrementX(dir), m.y1 + Direction.incrementY(dir)) && 
		(getChip(x + Direction.incrementX(dir), y + Direction.incrementY(dir)).getColor() == color)) {
		if (numberAdjacentChips(m.x1 + Direction.incrementX(dir), 
					m.y1 + Direction.incrementY(dir), color, m.x1, m.y1) > 0) {return false; }
	    }
	}
    }

    return true;


    // step moves
} else if (m.movekind == 2) {
    if !isValidSquare(m.x1, m.y1) {return false; }
    if !isValidSquare(m.x2, m.y2) {return false; }

    if (placedChips[color].length != 10) {return false; };

    if ((!hasChip(m.x1, m.y1)) || getChip(m.x1, m.y1).getColor() != 0) {return false; } // color doesn't match
    if hasChip(m.x2, m.y2) {return false; } // there's chip in step-to square
    if ((abs(m.x1 - m.x2) > 1) || (abs(m.y1 - m.y2) > 1)) {return false; } // step is not to adjacent square
            
    if (numberAdjacentChips(m.x2, m.y2, color, m.x1, m.y1) > 1) {return false; } // step-to square already would form 2 adjacencies

    for (int i = 0; i < 8; i++) {
	dir = directions[i];
	if ((m.x2 + Direction.incrementX(dir) == m.x1) || 
	    (m.y2 + Direction.incrementY(dir) == m.y1)) {continue; }
	if (hasChip(m.x2 + Direction.incrementX(dir), m.y2 + Direction.incrementY(dir)) && 
	    (getChip(x + Direction.incrementX(dir), y + Direction.incrementY(dir)).getColor() == color)) {
	    if (numberAdjacentChips(m.x2 + Direction.incrementX(dir), m.y2 + Direction.incrementY(dir), 
				    color, m.x1, m.y1) > 0) {return false; }                
	}
    }
}

return true;

} else { // moveKind != 2 ... 
      return false;
  }

}

// this doesn't account if it's the wrong turn. (evaluation heuristic breaks this)
public Move[] listValidMoves(int color) { // incomplete

    int dir;
    int x1;
    int y1;
    int x2;
    int y2;
    Move[] validMoves = new Move[100]; // there can't be more than 100 moves (48 max place moves; 10*8 step moves)
    Move current;

    if (placedChips[color].length == 10) { // step move
	Chip current;
	for (int i = 0; i < placedChips[color].length; i++) {
	    current = placedChips[color].length[i];
	    x1 = current.getPosition()[0];
	    y1 = current.getPosition()[1];
	    for (int j = 0; j < 8; j++) {
		dir = directions[j];
		x2 = x1 + Direction.incrementX(dir);
		y2 = y1 + Direction.incrementY(dir);
		current = new Move(x1, y1, x2, y2);
		if isValidMove(current, color) {
                        validMoves[validMoves.length] = current;
                    }
	    }                    
	}
    } else { // add move
	for (int x = 0; x < 8; x++) {
	    for (int y = 0; y < 8; y++) {
		current = new Move(x, y);
		if isValidMove(current, color) {
                        validMoves[validMoves.length] = current;
                    }
	    }
	}
    }
    return validMoves;
}

public float evaluation() { // also needs to be completed
    return -1;
        
    listValidMoves(0).length;
    listValidMoves(1).length;
}


}
